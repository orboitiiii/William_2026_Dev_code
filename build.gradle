plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2026.1.1"
    id "com.diffplug.spotless" version "6.25.0"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

def ROBOT_MAIN_CLASS = "frc.robot.Main"

// ============================================================================
// NATIVE C++ CONFIGURATION (Using Gradle Software Model)
// ============================================================================

// Apply native plugins for C++ compilation
apply plugin: 'cpp'

// Toolchain configuration for cross-compilation
model {
    platforms {
        // Desktop Windows x64
        windowsx64 {
            operatingSystem 'windows'
            architecture 'x86_64'
        }
        // RoboRIO (ARM Linux)
        linuxathena {
            operatingSystem 'linux'
            architecture 'arm'
        }
    }
    
    toolChains {
        // Visual C++ for Windows
        visualCpp(VisualCpp)
        
        // GCC for Windows (MinGW fallback)
        gcc(Gcc)
        
        // RoboRIO Cross-Compiler
        roborioGcc(Gcc) {
            // Add the toolchain path to Gradle's search paths
            path 'C:/Users/Public/wpilib/2026/roborio/bin'
            
            target('linuxathena') {
                cCompiler.executable = 'arm-frc2025-linux-gnueabi-gcc'
                cppCompiler.executable = 'arm-frc2025-linux-gnueabi-g++'
                linker.executable = 'arm-frc2025-linux-gnueabi-g++'
                assembler.executable = 'arm-frc2025-linux-gnueabi-as'
                staticLibArchiver.executable = 'arm-frc2025-linux-gnueabi-ar'
            }
        }
    }
    
    components {
        Team9427JNI(NativeLibrarySpec) {
            // NOTE: Windows JNI build temporarily disabled due to MSVC/Eigen compatibility issues.
            // The JNI library is only needed on the RoboRIO for actual robot operation.
            // For simulation, the Java implementation can fall back to pure Java alternatives.
            // TODO: Fix ESUKF.cpp for MSVC compatibility when simulation support is needed.
            
            // targetPlatform 'windowsx64'  // DISABLED: MSVC compile errors with Eigen
            
            // Build for RoboRIO only
            targetPlatform 'linuxathena'
            
            sources {
                cpp {
                    source {
                        srcDirs 'src/main/cpp'
                        srcDirs 'src/main/cpp/osqp/src'
                        include '**/*.cpp'
                        // Exclude Eigen benchmark/test files
                        exclude '**/include/eigen-3.4.0/**'
                    }
                    exportedHeaders {
                        srcDirs 'src/main/cpp'
                        srcDirs 'src/main/cpp/include'
                        srcDirs 'src/main/cpp/include/Eigen'
                        srcDirs 'src/main/cpp/osqp/include'
                        // JNI headers generated by javac
                        srcDirs 'build/generated/sources/headers/java/main'
                    }
                }
            }
            
            binaries.all {
                // Get JDK include path for jni.h
                def jdkHome = System.getProperty("java.home")
                def jniInclude = new File(jdkHome, "include").exists() ? jdkHome : file(jdkHome).parentFile
                
                if (targetPlatform.name == 'linuxathena') {
                    // RoboRIO-specific settings
                    cppCompiler.args '-std=c++20'
                    cppCompiler.args '-O3'
                    cppCompiler.args '-fPIC'
                    cppCompiler.args '-DEIGEN_NO_DEBUG'
                    cppCompiler.args '-I' + file('src/main/cpp/include/Eigen').absolutePath
                    cppCompiler.args '-I' + file('src/main/cpp/include').absolutePath
                    cppCompiler.args '-I' + file('src/main/cpp').absolutePath
                    cppCompiler.args '-I' + file('src/main/cpp/osqp/include').absolutePath
                    cppCompiler.args '-I' + file('build/generated/sources/headers/java/main').absolutePath
                    // CRITICAL: Linux jni_md.h must be included BEFORE jni.h directory
                    // Order matters: the compiler searches include paths in order
                    cppCompiler.args '-I' + file('src/main/cpp/include/linux').absolutePath
                    
                    // C Compiler settings for OSQP
                    cCompiler.args '-std=c11'
                    cCompiler.args '-O3'
                    cCompiler.args '-fPIC'
                    cCompiler.args '-I' + file('src/main/cpp/osqp/include').absolutePath
                    // WPILib JDK headers for cross-compilation
                    cppCompiler.args '-I' + 'C:/Users/Public/wpilib/2026/jdk/include'
                    // Linux JDK platform-specific headers (fallback)
                    cppCompiler.args '-I' + 'C:/Users/Public/wpilib/2026/jdk/include/linux'
                } else if (targetPlatform.name == 'windowsx64') {
                    // Windows-specific settings
                    if (toolChain in VisualCpp) {
                        cppCompiler.args '/std:c++20'
                        cppCompiler.args '/O2'
                        cppCompiler.args '/EHsc'
                        cppCompiler.args '/DEIGEN_NO_DEBUG'
                        cppCompiler.args "/I${file('src/main/cpp/include/Eigen').absolutePath}"
                        cppCompiler.args "/I${file('src/main/cpp/include').absolutePath}"
                        cppCompiler.args "/I${file('src/main/cpp').absolutePath}"
                        cppCompiler.args "/I${file('build/generated/sources/headers/java/main').absolutePath}"
                        cppCompiler.args "/I${jniInclude}/include"
                        cppCompiler.args "/I${jniInclude}/include/win32"
                    } else {
                        // GCC/MinGW
                        cppCompiler.args '-std=c++20'
                        cppCompiler.args '-O3'
                        cppCompiler.args '-DEIGEN_NO_DEBUG'
                        cppCompiler.args '-I' + file('src/main/cpp/include/Eigen').absolutePath
                        cppCompiler.args '-I' + file('src/main/cpp/include').absolutePath
                        cppCompiler.args '-I' + file('src/main/cpp').absolutePath
                        cppCompiler.args '-I' + file('build/generated/sources/headers/java/main').absolutePath
                        cppCompiler.args '-I' + "${jniInclude}/include"
                        cppCompiler.args '-I' + "${jniInclude}/include/win32"
                    }
                }
            }
        }
    }
}

// Task to generate JNI headers BEFORE native compilation
tasks.register('generateJniHeaders', JavaCompile) {
    dependsOn classes
    source = sourceSets.main.java
    classpath = sourceSets.main.compileClasspath
    destinationDirectory = file('build/jni-headers-temp')
    // Use -h to generate native headers
    options.compilerArgs.addAll(['-h', file('build/generated/sources/headers/java/main').absolutePath])
}

// Ensure JNI headers are generated before native build
tasks.withType(CppCompile).configureEach {
    dependsOn 'generateJniHeaders'
}

// ============================================================================
// DEPLOY CONFIGURATION
// ============================================================================

deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                }

                // Static files artifact
                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree('src/main/deploy')
                    directory = '/home/lvuser/deploy'
                    deleteOldFiles = false
                }
                
                // Deploy native JNI library to RoboRIO
                team9427JniDeploy(getArtifactTypeClass('FileArtifact')) {
                    // The shared library built for RoboRIO
                    file = project.file("${buildDir}/libs/Team9427JNI/shared/release/libTeam9427JNI.so")
                    directory = '/usr/local/frc/third-party/lib'
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

// Set to true to use debug for all targets including JNI
wpi.java.debugJni = false

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Quality of Life: Ensure native library is rebuilt before deploy
tasks.named('deployroborio').configure {
    dependsOn 'Team9427JNIReleaseSharedLibrary'
}

// ============================================================================
// DEPENDENCIES
// ============================================================================

dependencies {
    annotationProcessor wpi.java.deps.wpilibAnnotations()
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation configuration
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// JAR configuration
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from('src') { into 'backup/src' }
    from('vendordeps') { into 'backup/vendordeps' }
    from('build.gradle') { into 'backup' }
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Configure jar and deploy tasks
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure string concat to always inline compile
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
    options.encoding = 'UTF-8'
}

// Copy native library to a predictable location for simulation
tasks.register('copyNativeLibsForSimulation', Copy) {
    // Windows
    from("${buildDir}/libs/Team9427JNI/shared/windowsx64/release") {
        include '*.dll'
    }
    into "${buildDir}/nativelibs"
}

// Ensure simulation uses our native libraries
wpi.sim.envVar("PATH", "${buildDir}/nativelibs" + File.pathSeparator + System.getenv("PATH"))

task runVisualizer(type: JavaExec) {
    dependsOn classes
    dependsOn copyNativeLibsForSimulation
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'frc.robot.simulation.BallisticVisualizer'
    
    // Set library path for JNI
    systemProperty "java.library.path", "${buildDir}/nativelibs"
    // Also add to PATH for Windows DLL loading
    environment "PATH", "${buildDir}/nativelibs" + File.pathSeparator + System.getenv("PATH")
}

spotless {
    java {
        target fileTree('.') {
            include '**/*.java'
            exclude '**/build/**', '**/bin/**', '**/tools/**'
        }
        toggleOffOn()
        googleJavaFormat()
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
}
